/*
Copyright (c) 2021, QzIP Blockchain Technology LLP

All Rights Reserved.

Author: Ashish Banerjee, <ashish@qzip.in>


*/

package util

import (
	"math/big"
	"math/rand"
	"strings"
)

/*
Generates Base 24 sequence : 0-9,a-n

*/

// SeqGen generates Base 24 sequence : 0-9,a-n
type SeqGen struct {
	i *big.Int
}

// NewSeqGen  initializes a new SeqGen object
func NewSeqGen(seed uint64) *SeqGen {
	ret := &SeqGen{i: new(big.Int).SetUint64(seed)}
	//ret.i.SetUint64(24)
	return ret
}

// NewStringSeq generates sequence from base24 tring
func NewStringSeq(seq string) *SeqGen {
	ret := &SeqGen{}
	ret.i.SetString(strings.ToLower(seq), 24)
	return ret
}

//NewRandom generates a random number up to max uint64
func NewRandom(max uint64) *SeqGen {
	ret := &SeqGen{i: new(big.Int).SetUint64(rand.Uint64() % max)}
	//ret.i.SetUint64(24)
	return ret
}

//MaxSeq limit of the max len generated by random sequence
var MaxSeq = []byte("nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn")

//NewRandMaxLen generates a random number up to max lenght of base24
func NewRandMaxLen(b24len int) *SeqGen {
	if b24len > len(MaxSeq) {
		b24len = len(MaxSeq)
	}
	max := new(big.Int)
	max.SetString(string(MaxSeq[:b24len]), 24)
	ret := &SeqGen{i: new(big.Int).SetUint64(rand.Uint64() % max.Uint64())}
	return ret
}

var one *big.Int = new(big.Int).SetUint64(1)

// Next increments the sequence
func (seq *SeqGen) Next() {
	seq.i.Add(one, seq.i)
}

func (seq *SeqGen) String() string {
	return seq.i.Text(24)
}

//Uint64 get the underlying number
func (seq *SeqGen) Uint64() uint64 {
	return seq.i.Uint64()
}
