/*
Copyright (c) 2018, QzIP Blockchain Technology LLP

http://www.apache.org/licenses/LICENSE-2.0

Author: Ashish Banerjee, <ashish@qzip.in>

TODO: FIXME: Too many redirects error if using http.FileServer
       srvzip.go & xfs.go are there as a workaround
*/

package srvzip

import (
	"archive/zip"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

// MemZip File System Dir emulator required by http.FileServer
type MemZip struct {
	memzip    []byte
	zipReader *zip.Reader
}

// MinZipLen min lenght of a zip file.
const (
	MinZipLen = 100
)

//Debug TODO: refactor to align with qz Error Hanling framework
var Debug = false

// NewMemZip create an implementation of http.FileSystem from
//           a mem zip compressed file with Base64 encoded
//           use bin2b64.go
func NewMemZip(zipB64s string) (mz *MemZip, err error) {
	if len(zipB64s) < MinZipLen {
		mz = nil
		err = fmt.Errorf("memory zip file too short, please use bin2b64.go ")
	}
	mz = &MemZip{}

	mz.memzip, err = base64.StdEncoding.DecodeString(zipB64s)

	return
}

// Len Length of the underlying string represnting the
//     zip file. Generated by bin2b64.go
func (mz *MemZip) Len() int { return len(string(mz.memzip)) }

// ReadAt implements io.ReadAt
// https://golang.org/pkg/io/#ReaderAt
func (mz *MemZip) ReadAt(p []byte, off int64) (int, error) {
	//fmt.Println("ReadAt()\n")
	//fmt.Printf("p.len= %d, off= %d, mzip len = %d\n\n", len(p), off, len(mz.memzip))
	if int64(len(mz.memzip)) <= off {
		//	fmt.Println("ReadAt()-> sending EOF\n")
		return 0, io.EOF
	}
	//fmt.Printf("slide len=%d\n\n", len(mz.memzip[off:]))
	cplen := copy(p, mz.memzip[off:])
	/*
		cplen := func(i, j int) (min int) {
			min = i
			if i > j {
				min = j
			}
			return
		}(len(mz.memzip[off:]), len(p))
		j := 0
		for i := int(off); i < cplen; i++ {
			p[j] = mz.memzip[i]
			j++
		}
	*/
	//fmt.Printf("Copied len %d\n\n", cplen)
	return cplen, nil
}

// Close implements io.Closer
func (mz *MemZip) Close() error {
	mz.zipReader = nil
	return nil
}

// Open  a mem zip compressed file
func (mz *MemZip) Open(name string) (f http.File, err error) {
	if strings.Compare("/", name) == 0 {
		name = "index.html"
	} else if strings.HasPrefix(name, "/") {
		name = name[1:]
	}
	err = mz.openZip()
	if err != nil {
		if Debug {
			fmt.Printf(err.Error())
		}
		return nil, os.ErrNotExist
	}
	if Debug {
		fmt.Printf("\n\nMemZip.Open(%s)\n\n", name)
	}
	zf := mz.findFile(name)
	if zf == nil {
		err = os.ErrNotExist
		if Debug {
			fmt.Printf("File Not Found : %s\n", name)
		}
		return
	}
	f = &HttpFileAdapter{parent: mz, zfile: zf}
	err = (f.(*HttpFileAdapter)).Open()

	return
}

// HttpFileAdapter adapts zip.File to http.File interface
type HttpFileAdapter struct {
	parent *MemZip
	zfile  *zip.File
	fbuf   []byte
	curNdx int
}

// Open opens the memzip file
func (hfa *HttpFileAdapter) Open() (err error) {
	zrc, err := hfa.zfile.Open()
	if err == nil {
		hfa.fbuf, err = ioutil.ReadAll(zrc)
		hfa.curNdx = 0
		if err == nil {
			err = zrc.Close()
		}
	}
	return
}

// Readdir reads the fileInfo corresponding to the dir
func (hfa *HttpFileAdapter) Readdir(count int) (fi []os.FileInfo, err error) {

	fi = make([]os.FileInfo, 0, len(hfa.parent.zipReader.File))
	// filter the files
	for _, f := range hfa.parent.zipReader.File {
		if strings.HasPrefix(f.Name, hfa.zfile.Name) &&
			strings.Compare(f.Name, hfa.zfile.Name) != 0 {
			fi = append(fi, f.FileInfo())
		}
	}
	// https://golang.org/src/os/dir_unix.go#L38
	if len(fi) == 0 && err == nil && count > 0 {
		err = io.EOF
	}
	return
}

// Seek implements io.Seeker
func (hfa *HttpFileAdapter) Seek(offset int64, whence int) (int64, error) {
	newOff := 0
	switch whence {
	case io.SeekCurrent:
		newOff = hfa.curNdx + int(offset)
	case io.SeekEnd:
		newOff = len(hfa.fbuf) - 1 - int(offset)
	case io.SeekStart:
		newOff = int(offset)
	default:
		return 0, fmt.Errorf("Unknown whence value %d", whence)
	}
	if newOff >= len(hfa.fbuf) {
		return 0, fmt.Errorf("Seek Overflow %d", newOff)
	}
	hfa.curNdx = newOff
	return int64(newOff), nil
}

// Stat returns os.FileInfo or error
func (hfa *HttpFileAdapter) Stat() (os.FileInfo, error) {

	return hfa.zfile.FileInfo(), nil
}

func (hfa *HttpFileAdapter) Read(p []byte) (n int, err error) {
	if hfa.fbuf == nil {
		err = fmt.Errorf("MemZip File [%s] Not opened", hfa.zfile.Name)
		return
	}
	if hfa.curNdx >= len(hfa.fbuf) {
		err = io.EOF
		return
	}
	n = copy(p, hfa.fbuf[hfa.curNdx:])
	hfa.curNdx = hfa.curNdx + n
	return
}

// Close implements io.Close
func (hfa *HttpFileAdapter) Close() error {
	hfa.fbuf = nil
	return nil
}
func (mz *MemZip) findFile(name string) *zip.File {
	for _, f := range mz.zipReader.File {
		if strings.Compare(name, f.Name) == 0 {
			if Debug {
				fmt.Printf("findfile(%s) OK\n", name)
			}

			return f

		}
	}
	return nil
}

// GetFiles gets the underlying zip files & comment
func (mz *MemZip) GetFiles() (files []*zip.File, comment string, err error) {
	//fmt.Printf("GetFiles: len:%d\n\n", int64(mz.Len()))
	err = mz.openZip()
	files = mz.zipReader.File
	comment = mz.zipReader.Comment
	return
}
func (mz *MemZip) openZip() (err error) {
	//fmt.Println("openZip()\n")
	if mz.zipReader == nil {
		//	fmt.Println("openZip()->before NewReader\n\n")
		mz.zipReader, err = zip.NewReader(mz, int64(mz.Len()))
	}
	return
}

// FileServer wraps the http.FileServer
// FIXME: Not working (too many redirect error)
// TODO: $FIXME
func (mz *MemZip) FileServer() http.Handler {
	return http.FileServer(mz)
}

// OpenBrowser opens the local browser
// https://gist.github.com/hyg/9c4afcd91fe24316cbf0
func OpenBrowser(url string) {
	var err error

	switch runtime.GOOS {
	case "android":
		err = exec.Command("xdg-open", url).Start() // TODO check
	case "linux":
		err = exec.Command("xdg-open", url).Start()
	case "windows":
		err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
	case "ios":
		err = exec.Command("open", url).Start() // TODO check
	case "darwin":
		err = exec.Command("open", url).Start()
	default:
		err = fmt.Errorf("unsupported platform")
	}
	if err != nil {
		log.Fatal(err)
	}

}
